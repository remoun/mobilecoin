mod autogenerated_code {
    // Expose proto data types from included third-party/external proto files.
    pub use mc_api::external;
    pub use mc_attest_api::attest;
    pub use mc_fog_report_api::{report, report_grpc};
    pub use protobuf::well_known_types::empty;

    // Include the auto-generated code.
    include!(concat!(env!("OUT_DIR"), "/protos-auto-gen/mod.rs"));

    // For tests, we need to implement Eq on view::QueryRequest
    // They implement PartialEq but not Eq for some reason
    impl Eq for view::QueryRequest {}
    impl Eq for view::QueryRequestAAD {}
    impl Eq for kex_rng::KexRngPubkey {}
    impl Eq for kex_rng::StoredRng {}
}

pub use autogenerated_code::*;

pub mod conversions;
pub mod report_parse;

use grpcio::{CallOption, Metadata, Result as GrpcResult};
use mc_fog_enclave_connection::EnclaveGrpcChannel;
use mc_fog_uri::{IngestPeerUri, UriParseError};
use std::{collections::BTreeSet, str::FromStr};

// Extra functions for IngestSummary to avoid repetition
impl ingest_common::IngestSummary {
    pub fn sorted_peers(&self) -> Result<BTreeSet<IngestPeerUri>, UriParseError> {
        self.peers
            .iter()
            .map(|x| IngestPeerUri::from_str(x))
            .collect()
    }
}

// Implement the EnclaveGrpcChannel trait on attested service types.
// If we don't do this in this crate, then newtype wrappers must be used,
// because of orphan rules
impl EnclaveGrpcChannel for view_grpc::FogViewApiClient {
    fn auth(
        &mut self,
        msg: &attest::AuthMessage,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::AuthMessage, Metadata)> {
        <Self>::auth_async_opt(self, msg, call_option)?.receive_sync()
    }
    fn enclave_request(
        &mut self,
        msg: &attest::Message,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::Message, Metadata)> {
        <Self>::query_async_opt(self, msg, call_option)?.receive_sync()
    }
}

impl EnclaveGrpcChannel for ledger_grpc::FogKeyImageApiClient {
    fn auth(
        &mut self,
        msg: &attest::AuthMessage,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::AuthMessage, Metadata)> {
        <Self>::auth_async_opt(self, msg, call_option)?.receive_sync()
    }
    fn enclave_request(
        &mut self,
        msg: &attest::Message,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::Message, Metadata)> {
        <Self>::check_key_images_async_opt(self, msg, call_option)?.receive_sync()
    }
}

impl EnclaveGrpcChannel for ledger_grpc::FogMerkleProofApiClient {
    fn auth(
        &mut self,
        msg: &attest::AuthMessage,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::AuthMessage, Metadata)> {
        <Self>::auth_async_opt(self, msg, call_option)?.receive_sync()
    }
    fn enclave_request(
        &mut self,
        msg: &attest::Message,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::Message, Metadata)> {
        <Self>::outputs_async_opt(self, msg, call_option)?.receive_sync()
    }
}
